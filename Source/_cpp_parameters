# name   type   default   need in Fortran?   ifdef    fortran name    fortran type
#
# note, name can have two values, as (a, b).  a will be the name used
# in the inputs file, b is the variable name in the C++ class.


@namespace: castro Castro static

#-----------------------------------------------------------------------------
# category: AMR
#-----------------------------------------------------------------------------

# highest order used in interpolation
state_interp_order           int           1

# how to do limiting of the state data when interpolating
# 0: only prevent new extrema
# 1: preserve linear combinations of state variables
lin_limit_state_interp       int           0

# Number of ghost zones for state data to have. Note that
# if you are using radiation, choosing this to be zero will
# be overridden since radiation needs at least one ghost zone.
state_nghost                 int           0

# do we do the hyperbolic reflux at coarse-fine interfaces?
do_reflux                    int           1

# should we have state data for custom load-balancing weighting?
use_custom_knapsack_weights  int           0

#-----------------------------------------------------------------------------
# category: hydrodynamics
#-----------------------------------------------------------------------------

# the coefficient of the artificial viscosity
difmag                       Real          0.1                y

# the small density cutoff.  Densities below this value will be reset
small_dens                   Real         -1.e200             y

# the small temperature cutoff.  Temperatures below this value will
# be reset
small_temp                   Real         -1.e200             y

# the small pressure cutoff.  Pressures below this value will be reset
small_pres                   Real         -1.e200             y

# the small specific internal energy cutoff.  Internal energies below this
# value will be reset
small_ener                   Real         -1.e200             y

# permits hydro to be turned on and off for running pure rad problems
do_hydro                     int          -1                  y

# do we do the CTU unsplit method or a method-of-lines approach?
do_ctu                       int           0                  y

# whether to use the hybrid advection scheme that updates
# z-angular momentum, cylindrical momentum, and azimuthal
# momentum (3D only)
hybrid_hydro                 int           0                  y

# reconstruction type:
# 0: piecewise linear;
# 1: classic Colella \& Woodward ppm;
# 2: extrema-preserving ppm
ppm_type                     int           1                  y

# various methods of giving temperature a larger role in the
# reconstruction---see Zingale \& Katz 2015
ppm_temp_fix                 int           0                  y

# do we construct $\gamma_e = p/(\rho e) + 1$ and bring it
# to the interfaces for additional thermodynamic information
# (this is the Colella \& Glaz technique) or do we use $(\rho e)$
# (the classic \castro\ behavior).  Note this also uses
# $\tau = 1/\rho$ instead of $\rho$.
ppm_predict_gammae           int           0                  y

# do we use the reference state in evaluating the eigenvectors?
ppm_reference_eigenvectors   int           0                  y

# for piecewise linear, reconstruction order to use
plm_iorder                   int           2                  y

# do we drop from our regular Riemann solver to HLL when we
# are in shocks to avoid the odd-even decoupling instability?
hybrid_riemann               int           0                  y

# this is deprecated---use {\tt riemann\_solver} instead
use_colglaz                  int           -1

# which Riemann solver do we use:
# 0: Colella, Glaz, \& Ferguson (a two-shock solver);
# 1: Colella \& Glaz (a two-shock solver)
# 2: HLLC
riemann_solver               int           0                  y

# for the Colella \& Glaz Riemann solver, the maximum number
# of iterations to take when solving for the star state
cg_maxiter                   int          12                  y

# for the Colella \& Glaz Riemann solver, the tolerance to
# demand in finding the star state
cg_tol                       Real          1.0e-5             y

# for the Colella \& Glaz Riemann solver, what to do if
# we do not converge to a solution for the star state.
# 0 = do nothing; print iterations and exit
# 1 = revert to the original guess for p-star
# 2 = do a bisection search for another 2 * cg\_maxiter iterations.
cg_blend                     int           2                  y

# flatten the reconstructed profiles around shocks to prevent them
# from becoming too thin
use_flattening               int           1                  y

# after we add the transverse correction to the interface states, replace
# the predicted pressure with an EOS call (using $e$ and $\rho$).
transverse_use_eos           int           0                  y

# if the transverse interface state correction, if the new density is
# negative, then replace all of the interface quantities with their
# values without the transverse correction.
transverse_reset_density     int           1                  y

# if the interface state for $(\rho e)$ is negative after we add the
# transverse terms, then replace the interface value of $(\rho e)$
# with a value constructed from the $(\rho e)$ evolution equation
transverse_reset_rhoe        int           0                  y

# Allow internal energy resets and temperature flooring to change the
# total energy variable UEDEN in addition to the internal energy variable
# UEINT.
dual_energy_update_E_from_e  int           1                  y

# Threshold value of (E - K) / E such that above eta1, the hydrodynamic
# pressure is derived from E - K; otherwise, we use the internal energy
# variable UEINT.
dual_energy_eta1             Real          1.0e0              y

# Threshold value of (E - K) / E such that above eta2, we update the
# internal energy variable UEINT to match E - K. Below this, UEINT
# remains unchanged.
dual_energy_eta2             Real          1.0e-4             y

# Threshold value of (E - K) / E such that above eta3, the temperature used
# in the burning module is derived from E-K; otherwise, we use UEINT.
dual_energy_eta3             Real          1.0e0              y

# for the piecewise linear reconstruction, do we subtract off $(\rho g)$
# from the pressure before limiting?
use_pslope                   int           1                  y

fix_mass_flux                int           0                  y

# Should we limit the density fluxes so that we do not create small densities?
limit_fluxes_on_small_dens   int           0                  y

# Which method to use when resetting a negative/small density
# 1 = Reset to characteristics of adjacent zone with largest density
# 2 = Use average of all adjacent zones for all state variables
# 3 = Reset to the original zone state before the hydro update
density_reset_method         int           1                  y

# Whether or not to allow internal energy to be less than zero
allow_negative_energy        int           0                  y

# Whether or not to allow the internal energy to be less than the
# internal energy corresponding to small\_temp
allow_small_energy           int           1                  y

# set the flattening parameter to zero to force the reconstructed profiles
# to be flat, resulting in a first-order method
first_order_hydro            int           0                  y

# if we are doing an external -x boundary condition, who do we interpret it?
xl_ext_bc_type               string        ""                 y

# if we are doing an external +x boundary condition, who do we interpret it?
xr_ext_bc_type               string        ""                 y

# if we are doing an external -y boundary condition, who do we interpret it?
yl_ext_bc_type               string        ""                 y

# if we are doing an external +y boundary condition, who do we interpret it?
yr_ext_bc_type               string        ""                 y

# if we are doing an external -z boundary condition, who do we interpret it?
zl_ext_bc_type               string        ""                 y

# if we are doing an external +z boundary condition, who do we interpret it?
zr_ext_bc_type               string        ""                 y

# if we are doing HSE boundary conditions, do we zero the velocity?
hse_zero_vels                int           0                  y

# if we are doing HSE boundary conditions, should we get the temperature
# via interpolation (using model\_parser) or hold it constant?
hse_interp_temp              int           0                  y

# if we are doing HSE boundary conditions, how do we treat the velocity?
# reflect? or outflow?
hse_reflect_vels             int           0                  y

#-----------------------------------------------------------------------------
# category: timestep control
#-----------------------------------------------------------------------------

# a fixed timestep to use for all steps (negative turns it off)
fixed_dt                     Real         -1.0

# the initial timestep (negative uses the step returned from the timestep
# constraints)
initial_dt                   Real         -1.0

# the smallest valid timestep---if we go below this, we abort
dt_cutoff                    Real          0.0

# the largest valid timestep---limit all timesteps to be no larger than this
max_dt                       Real          1.e200

# the effective Courant number to use---we will not allow the hydrodynamic
# waves to cross more than this fraction of a zone over a single timestep
cfl                          Real          0.8                y

# a factor by which to reduce the first timestep from that requested by
# the timestep estimators
init_shrink                  Real          1.0

# the maximum factor by which the timestep can increase from one step to
# the next.
change_max                   Real          1.1

# Retry a timestep if it violated the timestep-limiting criteria over
# the course of an advance. The criteria will suggest a new timestep
# that satisfies the criteria, and we will do subcycled timesteps
# on the same level until we reach the original target time.
use_retry                    int           0

# Check for a possible post-timestep regrid if certain stability
# criteria were violated.
use_post_step_regrid         int           0

# Do not permit more retry timesteps than this parameter.
# Set to a negative value to disable this criterion.
retry_max_subcycles          int           1000

# If we're doing retries, set the target threshold for changes in density
# if a retry is triggered by a negative density. If this is set to a negative
# number then it will disable retries using this criterion.
retry_neg_dens_factor        Real          1.e-1

# Number of iterations for the SDC advance.
sdc_iters                    int           2


#-----------------------------------------------------------------------------
# category: parallelization
#-----------------------------------------------------------------------------

# determines whether we use accelerators for specific loops
do_acc                       int          -1                  y

bndry_func_thread_safe       int           1


#-----------------------------------------------------------------------------
# category: embiggening
#-----------------------------------------------------------------------------

# the factor by which to extend the domain upon restart for embiggening
grown_factor                 int           1                  y

# used with the embiggening routines to determine how to extend the domain
star_at_center               int          -1


#-----------------------------------------------------------------------------
# category: refinement
#-----------------------------------------------------------------------------


do_special_tagging           int           0

spherical_star               int           0


#-----------------------------------------------------------------------------
# category: diagnostics
#-----------------------------------------------------------------------------

# display warnings in Fortran90 routines
print_fortran_warnings       int           (0, 1)

# calculate losses of material through physical grid boundaries
track_grid_losses            int            0                    y

# how often (number of coarse timesteps) to compute integral sums (for runtime diagnostics)
sum_interval                 int           -1

# how often (simulation time) to compute integral sums (for runtime diagnostics)
sum_per                      Real          -1.0e0

# display center of mass diagnostics
show_center_of_mass          int           0

# abort if we exceed CFL = 1 over the cource of a timestep
hard_cfl_limit               int           1

# a string describing the simulation that will be copied into the
# plotfile's {\tt job\_info} file
job_name                     string        ""

# write a final plotfile and checkpoint upon completion
output_at_completion         int           1



